<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ChessVision v3 - Stable Rendering</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        /* Custom scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        
        .source-container { position: relative; overflow: hidden; display: inline-block; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5); touch-action: none; }
        .selection-box { border: 2px dashed #60a5fa; background-color: rgba(96, 165, 250, 0.2); position: absolute; pointer-events: none; z-index: 50; }
        
        /* Chess Board Styles */
        .chess-square { width: 12.5%; height: 12.5%; float: left; display: flex; align-items: center; justify-content: center; position: relative; }
        
        /* FIXED: Pieces now have position: relative and higher z-index to sit ABOVE the arrow canvas */
        .piece { width: 80%; height: 80%; background-size: contain; background-repeat: no-repeat; background-position: center; cursor: grab; position: relative; z-index: 20; }
        .piece:active { cursor: grabbing; }
        
        .white-square { background-color: #eeeed2; color: #769656; }
        .black-square { background-color: #769656; color: #eeeed2; }
        
        /* Overlay for arrows - Z-index 10 is lower than pieces (20) */
        #board-overlay-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
    </style>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
</head>
<body class="bg-gray-900 text-gray-100 font-sans h-screen overflow-hidden">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- Constants & Helpers ---
        const STOCKFISH_URL = "https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.0/stockfish.js";
        // Using Wikimedia images
        const PIECE_URLS = { 'p': 'https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg', 'r': 'https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg', 'n': 'https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg', 'b': 'https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg', 'q': 'https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg', 'k': 'https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg', 'P': 'https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg', 'R': 'https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg', 'N': 'https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg', 'B': 'https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg', 'Q': 'https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg', 'K': 'https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg' };
        const FILES = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
        const RANKS = ['8', '7', '6', '5', '4', '3', '2', '1'];

        // Extract FEN using Regex to be safe against AI chatty responses
        const extractFen = (text) => {
            // Looks for pattern: piece placement + turn + castling + en passant + clocks
            const complexFenRegex = /([rnbqkpRNBQKP1-8]+\/){7}[rnbqkpRNBQKP1-8]+ [wb] [-KkQq]+ [-a-h36]+ \d+ \d+/;
            const simpleFenRegex = /([rnbqkpRNBQKP1-8]+\/){7}[rnbqkpRNBQKP1-8]+/;
            
            const matchComplex = text.match(complexFenRegex);
            if (matchComplex) return matchComplex[0];
            
            const matchSimple = text.match(simpleFenRegex);
            if (matchSimple) return matchSimple[0] + " w - - 0 1"; // Default fallbacks
            
            return null;
        };

        const drawArrow = (ctx, fromSq, toSq, color, lineWidth) => {
            const fileIdx = FILES.indexOf(fromSq[0]);
            const rankIdx = RANKS.indexOf(fromSq[1]);
            const toFileIdx = FILES.indexOf(toSq[0]);
            const toRankIdx = RANKS.indexOf(toSq[1]);
            const sqSize = ctx.canvas.width / 8;
            const x1 = fileIdx * sqSize + sqSize / 2;
            const y1 = rankIdx * sqSize + sqSize / 2;
            const x2 = toFileIdx * sqSize + sqSize / 2;
            const y2 = toRankIdx * sqSize + sqSize / 2;
            const headLen = sqSize * 0.3;
            const angle = Math.atan2(y2 - y1, x2 - x1);

            ctx.beginPath();
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headLen * Math.cos(angle - Math.PI / 6), y2 - headLen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(x2 - headLen * Math.cos(angle + Math.PI / 6), y2 - headLen * Math.sin(angle + Math.PI / 6));
            ctx.lineTo(x2, y2);
            ctx.fill();
        };

        const SettingsModal = ({ isOpen, onClose, apiKey, setApiKey, modelId, setModelId }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-lg shadow-xl w-full max-w-md p-6 border border-gray-700">
                        <h2 className="text-xl font-bold mb-4 text-white"><i className="fas fa-cog mr-2"></i>Settings</h2>
                        <div className="mb-4">
                            <label className="block text-gray-400 text-sm font-bold mb-2">Google Gemini API Key</label>
                            <input type="password" value={apiKey} onChange={(e) => setApiKey(e.target.value)} className="w-full bg-gray-700 text-white border border-gray-600 rounded py-2 px-3 focus:outline-none focus:border-blue-500" />
                        </div>
                        <div className="mb-6">
                            <label className="block text-gray-400 text-sm font-bold mb-2">Model ID</label>
                            <input type="text" value={modelId} onChange={(e) => setModelId(e.target.value)} className="w-full bg-gray-700 text-white border border-gray-600 rounded py-2 px-3 focus:outline-none focus:border-blue-500" />
                        </div>
                        <div className="flex justify-end"><button onClick={onClose} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition">Save & Close</button></div>
                    </div>
                </div>
            );
        };

        const ChessBoard = ({ fen, setFen, onMove, bestMoves, showArrows }) => {
            const [game, setGame] = useState(new Chess(fen));
            const [selectedSquare, setSelectedSquare] = useState(null);
            const overlayRef = useRef(null);
            const boardRef = useRef(null);

            // Update game state safely
            useEffect(() => { 
                try { 
                    const newGame = new Chess(fen); 
                    setGame(newGame); 
                } catch (e) { 
                    // If FEN is invalid, we do NOT update the game state,
                    // preserving the previous valid position to avoid "disappearing" pieces.
                    console.error("Invalid FEN:", fen);
                } 
            }, [fen]);

            // Arrow Drawing
            useEffect(() => {
                const canvas = overlayRef.current;
                if (!canvas || !boardRef.current) return;
                const ctx = canvas.getContext('2d');
                // Ensure canvas is cleared completely
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const rect = boardRef.current.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;

                if (showArrows && bestMoves && bestMoves.length > 0) {
                    const topMoveStr = bestMoves[0].pv.split(' ')[0];
                    if(topMoveStr.length === 4 || topMoveStr.length === 5) {
                         drawArrow(ctx, topMoveStr.substring(0, 2), topMoveStr.substring(2, 4), 'rgba(34, 197, 94, 0.8)', 6);
                    }
                    for(let i=1; i < bestMoves.length; i++) {
                        const moveStr = bestMoves[i].pv.split(' ')[0];
                         if(moveStr.length === 4 || moveStr.length === 5) {
                            drawArrow(ctx, moveStr.substring(0, 2), moveStr.substring(2, 4), 'rgba(59, 130, 246, 0.6)', 4);
                         }
                    }
                }
            }, [bestMoves, showArrows, fen, game]); // Dependency on 'game' ensures redraw after re-render

            const handleSquareClick = (square) => {
                if (selectedSquare === square) { setSelectedSquare(null); return; }
                if (selectedSquare) {
                    const move = game.move({ from: selectedSquare, to: square, promotion: 'q' });
                    if (move) { setFen(game.fen()); setSelectedSquare(null); if (onMove) onMove(game.fen()); } 
                    else {
                        const piece = game.get(square);
                        if (piece && piece.color === game.turn()) setSelectedSquare(square); else setSelectedSquare(null);
                    }
                } else {
                    const piece = game.get(square);
                    if (piece && piece.color === game.turn()) setSelectedSquare(square);
                }
            };

            const board = [];
            for (let r = 0; r < 8; r++) {
                for (let f = 0; f < 8; f++) {
                    const square = FILES[f] + RANKS[r];
                    const isBlack = (r + f) % 2 === 1;
                    const piece = game.get(square);
                    const isSelected = selectedSquare === square;
                    const lastMove = game.history({ verbose: true }).pop();
                    const isLastMove = lastMove && (lastMove.from === square || lastMove.to === square);
                    
                    let overlayStyle = {};
                    if (isSelected) overlayStyle.backgroundColor = 'rgba(255, 255, 0, 0.5)';
                    else if (isLastMove) overlayStyle.backgroundColor = 'rgba(155, 199, 0, 0.41)';

                    board.push(
                        <div key={square} className={`${isBlack ? 'black-square' : 'white-square'} chess-square`} onClick={() => handleSquareClick(square)}>
                            <div className="absolute inset-0" style={overlayStyle}></div>
                            {piece && (
                                <div className="piece" 
                                     style={{ backgroundImage: `url(${PIECE_URLS[piece.type === 'p' && piece.color === 'w' ? 'P' : piece.type === 'p' && piece.color === 'b' ? 'p' : piece.color === 'w' ? piece.type.toUpperCase() : piece.type]})` }}
                                ></div>
                            )}
                            {f === 0 && <span className={`absolute top-0 left-1 text-xs font-bold ${isBlack ? 'text-[#eeeed2]' : 'text-[#769656]'}`}>{RANKS[r]}</span>}
                            {r === 7 && <span className={`absolute bottom-0 right-1 text-xs font-bold ${isBlack ? 'text-[#eeeed2]' : 'text-[#769656]'}`}>{FILES[f]}</span>}
                        </div>
                    );
                }
            }

            return (
                <div className="flex flex-col items-center w-full max-w-[500px]">
                    <div ref={boardRef} className="w-full aspect-square border-4 border-gray-700 shadow-2xl relative">
                        {/* Canvas is absolutely positioned, but Z-index 10 is < Piece Z-index 20 */}
                        <canvas ref={overlayRef} id="board-overlay-canvas"></canvas>
                        {board}
                    </div>
                    <div className="w-full mt-4">
                        <label className="text-xs text-gray-500 uppercase font-bold tracking-wider">FEN String</label>
                        <input className="w-full bg-gray-800 border border-gray-600 text-gray-300 text-xs font-mono p-2 rounded mt-1 focus:border-blue-500 outline-none" value={fen} onChange={(e) => { setFen(e.target.value); if(onMove) onMove(e.target.value); }} />
                    </div>
                </div>
            );
        };

        const App = () => {
            const [apiKey, setApiKey] = useState(localStorage.getItem('gemini_api_key') || '');
            const [modelId, setModelId] = useState(localStorage.getItem('gemini_model_id') || 'gemini-1.5-pro');
            const [showSettings, setShowSettings] = useState(false);
            const [isLoading, setIsLoading] = useState(false);
            const [loadingMsg, setLoadingMsg] = useState('');
            const [errorMsg, setErrorMsg] = useState('');

            const [pdfDoc, setPdfDoc] = useState(null);
            const [pageNum, setPageNum] = useState(1);
            const [imageSrc, setImageSrc] = useState(null);
            const canvasRef = useRef(null);
            const containerRef = useRef(null);

            const [isSelecting, setIsSelecting] = useState(false);
            const [selectionStart, setSelectionStart] = useState({ x: 0, y: 0 });
            const [selectionBox, setSelectionBox] = useState(null);

            const [fen, setFen] = useState('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1');
            const [bestMoves, setBestMoves] = useState([]);
            const [showBestMoves, setShowBestMoves] = useState(true);
            const stockfishWorker = useRef(null);

            useEffect(() => {
                if (apiKey) localStorage.setItem('gemini_api_key', apiKey);
                if (modelId) localStorage.setItem('gemini_model_id', modelId);
            }, [apiKey, modelId]);

            useEffect(() => {
                fetch(STOCKFISH_URL).then(r => r.text()).then(scriptContent => {
                    const blob = new Blob([scriptContent], { type: 'application/javascript' });
                    stockfishWorker.current = new Worker(URL.createObjectURL(blob));
                    let currentMoves = [];
                    stockfishWorker.current.onmessage = (e) => {
                        const line = e.data;
                        if (line.startsWith('info') && line.includes('pv')) {
                            const multipvMatch = line.match(/multipv\s+(\d+)/);
                            const scoreMatch = line.match(/score\s+(cp|mate)\s+(-?\d+)/);
                            const pvMatch = line.match(/\spv\s+(.*)/);
                            if (multipvMatch && scoreMatch && pvMatch) {
                                const rank = parseInt(multipvMatch[1]) - 1;
                                const type = scoreMatch[1];
                                let scoreVal = parseInt(scoreMatch[2]);
                                const scoreLabel = type === 'mate' ? `#M${Math.abs(scoreVal)}` : (scoreVal / 100).toFixed(2);
                                currentMoves[rank] = { rank: rank + 1, score: scoreLabel, pv: pvMatch[1], type: type };
                                setBestMoves([...currentMoves].filter(Boolean));
                            }
                        }
                    };
                    stockfishWorker.current.postMessage('uci');
                    stockfishWorker.current.postMessage('setoption name MultiPV value 3');
                    stockfishWorker.current.postMessage('isready');
                });
                return () => { if (stockfishWorker.current) stockfishWorker.current.terminate(); };
            }, []);

            useEffect(() => {
                if (stockfishWorker.current) {
                    setBestMoves([]);
                    stockfishWorker.current.postMessage('stop');
                    stockfishWorker.current.postMessage(`position fen ${fen}`);
                    stockfishWorker.current.postMessage('go depth 15');
                }
            }, [fen]);

            useEffect(() => {
                if (!canvasRef.current) return;
                const canvas = canvasRef.current;
                const context = canvas.getContext('2d');
                if (imageSrc) {
                    const img = new Image();
                    img.onload = () => { canvas.width = img.width; canvas.height = img.height; context.drawImage(img, 0, 0); };
                    img.src = imageSrc;
                } else if (pdfDoc) {
                    const renderPage = async () => {
                        try {
                            const page = await pdfDoc.getPage(pageNum);
                            const scale = window.innerWidth < 768 ? 1.5 : 2.0; 
                            const viewport = page.getViewport({ scale });
                            canvas.height = viewport.height;
                            canvas.width = viewport.width;
                            await page.render({ canvasContext: context, viewport: viewport }).promise;
                        } catch (err) { setErrorMsg("Error rendering page."); }
                    };
                    renderPage();
                }
            }, [pdfDoc, pageNum, imageSrc]);

            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                setErrorMsg('');
                setSelectionBox(null);
                if (file.type === 'application/pdf') {
                    setImageSrc(null);
                    const reader = new FileReader();
                    reader.onload = async (ev) => {
                        try {
                            const typedarray = new Uint8Array(ev.target.result);
                            const pdf = await pdfjsLib.getDocument(typedarray).promise;
                            setPdfDoc(pdf); setPageNum(1);
                        } catch (err) { setErrorMsg("Invalid PDF file."); }
                    };
                    reader.readAsArrayBuffer(file);
                } else if (file.type.startsWith('image/')) {
                    setPdfDoc(null);
                    const reader = new FileReader();
                    reader.onload = (ev) => { setImageSrc(ev.target.result); };
                    reader.readAsDataURL(file);
                } else { setErrorMsg("Unsupported file type."); }
            };

            const getPointerCoords = (e) => {
                if (!containerRef.current) return { x: 0, y: 0 };
                const rect = containerRef.current.getBoundingClientRect();
                let clientX = e.clientX; let clientY = e.clientY;
                if (e.touches && e.touches.length > 0) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
                else if (e.changedTouches && e.changedTouches.length > 0) { clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; }
                return { x: clientX - rect.left, y: clientY - rect.top };
            };
            const handlePointerDown = (e) => {
                if (!pdfDoc && !imageSrc) return;
                setIsSelecting(true);
                const coords = getPointerCoords(e);
                setSelectionStart(coords); setSelectionBox(null);
            };
            const handlePointerMove = (e) => {
                if (!isSelecting) return;
                const coords = getPointerCoords(e);
                setSelectionBox({ x: Math.min(selectionStart.x, coords.x), y: Math.min(selectionStart.y, coords.y), w: Math.abs(coords.x - selectionStart.x), h: Math.abs(coords.y - selectionStart.y) });
            };
            const handlePointerUp = () => setIsSelecting(false);

            const scanSelection = async () => {
                if (!selectionBox || !canvasRef.current) return;
                if (!apiKey) { setShowSettings(true); return; }
                setIsLoading(true); setLoadingMsg("AI Analyzing...");
                try {
                    const canvas = canvasRef.current;
                    const rect = containerRef.current.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
                    const cropW = selectionBox.w * scaleX; const cropH = selectionBox.h * scaleY;
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = cropW; tempCanvas.height = cropH;
                    tempCanvas.getContext('2d').drawImage(canvas, selectionBox.x * scaleX, selectionBox.y * scaleY, cropW, cropH, 0, 0, cropW, cropH);
                    const base64Image = tempCanvas.toDataURL('image/jpeg').split(',')[1];

                    const payload = { contents: [{ parts: [{ text: "Analyze this chess diagram. Return ONLY the FEN string. If unsure of the turn, assume 'w'. Do not include markdown." }, { inline_data: { mime_type: "image/jpeg", data: base64Image } }] }] };
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    const data = await response.json();
                    if (data.error) throw new Error(data.error.message);
                    
                    const rawText = data.candidates[0].content.parts[0].text;
                    const cleanedFen = extractFen(rawText);
                    
                    if (cleanedFen) setFen(cleanedFen); 
                    else setErrorMsg("AI returned invalid FEN data.");
                    
                } catch (err) { setErrorMsg("Scan failed: " + err.message); } 
                finally { setIsLoading(false); setSelectionBox(null); }
            };

            const sortedMoves = bestMoves.sort((a, b) => (a.type === 'mate' && b.type !== 'mate' ? -1 : (b.type === 'mate' && a.type !== 'mate' ? 1 : a.rank - b.rank)));
            const mainEval = sortedMoves.length > 0 ? sortedMoves[0].score : "Calculating...";
            const evalColorStr = (mainEval.toString().startsWith('-') && !fen.includes(' b ')) || (!mainEval.toString().startsWith('-') && fen.includes(' b ')) ? 'text-red-400' : 'text-green-400';

            return (
                <div className="flex flex-col h-full">
                    <header className="bg-gray-800 border-b border-gray-700 p-4 flex justify-between items-center shrink-0">
                        <div className="flex items-center gap-2">
                            <i className="fas fa-chess-knight text-blue-500 text-2xl"></i>
                            <h1 className="text-xl font-bold tracking-tight">Chess<span className="text-blue-500">Vision</span> v3</h1>
                        </div>
                        <button onClick={() => setShowSettings(true)} className="text-gray-400 hover:text-white transition"><i className="fas fa-cog text-xl"></i></button>
                    </header>
                    <div className="flex flex-1 overflow-hidden">
                        <div className="flex-1 bg-gray-900 p-4 flex flex-col items-center overflow-auto border-r border-gray-800 relative select-none" onMouseUp={handlePointerUp} onTouchEnd={handlePointerUp}>
                            <div className="w-full max-w-3xl flex justify-between items-center mb-4 sticky top-0 z-20 bg-gray-900/90 backdrop-blur py-2">
                                <label className="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded cursor-pointer text-sm font-medium transition flex items-center">
                                    <i className="fas fa-upload mr-2"></i>Upload
                                    <input type="file" accept=".pdf, .jpg, .jpeg, .png, .webp" className="hidden" onChange={handleFileUpload} />
                                </label>
                                {pdfDoc && (
                                    <div className="flex items-center gap-4 bg-gray-800 px-3 py-1 rounded-full border border-gray-700">
                                        <button onClick={() => setPageNum(p => Math.max(1, p - 1))} className="text-gray-400 hover:text-white"><i className="fas fa-chevron-left"></i></button>
                                        <span className="text-sm font-mono text-gray-300">{pageNum}/{pdfDoc.numPages}</span>
                                        <button onClick={() => setPageNum(p => Math.min(pdfDoc.numPages, p + 1))} className="text-gray-400 hover:text-white"><i className="fas fa-chevron-right"></i></button>
                                    </div>
                                )}
                            </div>
                            {(pdfDoc || imageSrc) ? (
                                <div className="relative group">
                                    <div ref={containerRef} className="source-container cursor-crosshair border border-gray-700" onMouseDown={handlePointerDown} onMouseMove={handlePointerMove} onTouchStart={handlePointerDown} onTouchMove={handlePointerMove}>
                                        <canvas ref={canvasRef} className="block max-w-full h-auto" />
                                        {selectionBox && (
                                            <div className="selection-box flex items-end justify-end p-1" style={{ left: selectionBox.x, top: selectionBox.y, width: selectionBox.w, height: selectionBox.h }}>
                                                <button onMouseDown={(e) => e.stopPropagation()} onTouchStart={(e) => e.stopPropagation()} onClick={scanSelection} className="bg-blue-600 text-white text-xs font-bold px-2 py-1 rounded shadow-lg hover:bg-blue-500 pointer-events-auto">SCAN</button>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            ) : (
                                <div className="flex-1 flex flex-col items-center justify-center text-gray-500 gap-4">
                                    <i className="fas fa-file-image text-6xl opacity-50"></i>
                                    <p className="text-lg">Upload PDF or Image</p>
                                </div>
                            )}
                        </div>
                        <div className="w-[300px] md:w-[400px] bg-gray-800 p-4 flex flex-col border-l border-gray-700 shrink-0 overflow-y-auto hidden md:flex">
                            <div className="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                                <h2 className="text-lg font-bold text-gray-200">Analysis Board</h2>
                                <button onClick={() => setShowBestMoves(!showBestMoves)} className={`text-gray-400 hover:text-white transition ${showBestMoves ? 'text-blue-400' : ''}`}><i className={`fas ${showBestMoves ? 'fa-eye' : 'fa-eye-slash'}`}></i></button>
                            </div>
                            <div className="w-full bg-gray-700/50 rounded p-3 mb-4 flex justify-between items-center border border-gray-600">
                                <span className="text-gray-300 font-medium flex items-center gap-2"><i className="fas fa-microchip"></i> Eval:</span>
                                <span className={`font-mono font-bold text-lg ${evalColorStr}`}>{mainEval}</span>
                            </div>
                            <ChessBoard fen={fen} setFen={setFen} onMove={(f) => setFen(f)} bestMoves={sortedMoves} showArrows={showBestMoves} />
                            {showBestMoves && sortedMoves.length > 0 && (
                                <div className="mt-6 animate-fade-in">
                                    <h3 className="text-sm font-bold text-gray-400 uppercase tracking-wider mb-2">Top Lines</h3>
                                    <div className="space-y-2">
                                        {sortedMoves.map((move, idx) => (
                                            <div key={idx} className={`p-2 rounded flex justify-between items-start text-sm ${idx === 0 ? 'bg-green-900/30 border border-green-700/50' : 'bg-gray-700/30 border border-gray-700/50'}`}>
                                                <div className="flex gap-2">
                                                    <span className={`font-mono font-bold ${idx === 0 ? 'text-green-400' : 'text-blue-400'}`}>{move.rank}.</span>
                                                    <span className="font-medium text-gray-200">{move.pv}</span>
                                                </div>
                                                <span className={`font-mono font-bold ${move.score.toString().includes('M') ? 'text-purple-400' : (idx===0 ? evalColorStr : 'text-gray-400')}`}>{move.score}</span>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                    <div className="md:hidden p-4 bg-gray-800 border-t border-gray-700 shrink-0 h-1/3 min-h-[300px] overflow-y-auto overflow-x-hidden">
                         <div className="flex justify-between mb-2">
                            <span className={`font-mono font-bold ${evalColorStr}`}>Eval: {mainEval}</span>
                             <button onClick={() => setShowBestMoves(!showBestMoves)} className="text-gray-400"><i className={`fas ${showBestMoves ? 'fa-eye' : 'fa-eye-slash'}`}></i></button>
                         </div>
                         <ChessBoard fen={fen} setFen={setFen} onMove={(f) => setFen(f)} bestMoves={sortedMoves} showArrows={showBestMoves} />
                    </div>
                    <SettingsModal isOpen={showSettings} onClose={() => setShowSettings(false)} apiKey={apiKey} setApiKey={setApiKey} modelId={modelId} setModelId={setModelId} />
                    {isLoading && (
                        <div className="fixed inset-0 bg-black bg-opacity-80 flex flex-col items-center justify-center z-50">
                            <div className="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-blue-500 mb-4"></div>
                            <p className="text-blue-400 font-mono animate-pulse">{loadingMsg}</p>
                        </div>
                    )}
                    {errorMsg && (
                         <div className="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-red-600 text-white px-6 py-3 rounded shadow-lg z-50 flex items-center gap-3 w-max max-w-sm">
                            <i className="fas fa-exclamation-circle"></i>
                            <span className="text-sm">{errorMsg}</span>
                            <button onClick={() => setErrorMsg('')} className="ml-2 hover:text-gray-200"><i className="fas fa-times"></i></button>
                        </div>
                    )}
                </div>
            );
        };
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
